#!/usr/bin/env ruby

# frozen_string_literal: true

require "bundler/inline"
require "singleton"

gemfile do
  source "https://rubygems.org"

  gem "toml-rb"
  gem "tty-option"
  gem "tty-table"
end

class Styr
  class Config
    CONFIG_PATH = Pathname.new(Dir.pwd).join(".config/styr.toml")

    def self.load
      @config ||= if File.exist?(CONFIG_PATH) # rubocop:disable Naming/MemoizedInstanceVariableName
        TomlRB.load_file(CONFIG_PATH)
      else
        {}
      end
    end
  end

  class Target
    attr_reader :name, :config

    def initialize(name, config)
      @name = name
      @config = config
    end

    def backend
      @backend ||= Styr::Backend.from_config(@config.fetch("backend"))
    end
  end
end

class Styr
  include Singleton

  def process_input_command(input_command, args = [])
    Styr::CLI.process(input_command, args)
  end

  def targets
    return @targets if @targets

    config = Config.load
    targets_config = config["targets"] || {}
    @targets = targets_config.map do |target_name, target_config|
      Target.new(target_name, target_config)
    end
  end
end

class Styr
  class Backend
    class HerokuBackend
      def initialize(config)
        @config = config
      end

      def execute(command)
        puts "Executing '#{command}' on backend #{@config['backend']} for app #{@config['app']}"
      end

      def to_s
        "Heroku"
      end
    end

    class SSHBackend
      def initialize(config)
        @config = config
      end

      def execute(command)
        puts "Executing '#{command}' on backend #{@config['backend']} for app #{@config['app']}"
      end

      def to_s
        "SSH"
      end
    end

    class << self
      def from_config(backend_type, config = {})
        backend_class =
          case backend_type.downcase
          when "heroku"
            HerokuBackend
          when "ssh"
            SSHBackend
          else
            raise "Unknown backend type: #{backend_type}"
          end
        backend_class.new(config)
      end
    end
  end

  class CLI
    include TTY::Option

    program "styr"

    class << self
      def process(input_command, args = [])
        task = tasks.find do |task_class|
          task_class.command.include?(input_command)
        end

        if task
          command = task.new
          p ["Parsing", input_command, args, ARGV]
          command.parse
          command.run
        else
          puts "Wut?"
          puts Styr::CLI.new.help
        end
      end

      def tasks
        [
          RunTask,
          TargetsTask
        ]
      end
    end

    class Task < CLI
      include TTY::Option

      command "run"

      usage do
        desc "Do stuff"
      end

      flag :help do
        desc "Print usage"
      end

      def run
        if params[:help]
          puts "help"
          print help
        elsif params.errors.any?
          puts "errors"
          puts params.errors.summary
        else
          puts "params"
          pp params.to_h
        end
      end
    end

    class RunTask < Task
      command "run"

      option :target do
        convert :list
        desc "Target to run the command on"
        long "--target=TARGET"
        permit Styr.instance.targets.map(&:name)
        required
        short "-t"
      end

      argument :remote_command do
        required
        desc "The command to run on the target"
      end

      usage do
        desc "Run a command on the specified target"
      end

      def run
        exit_with_help if params[:help]

        validate_inputs
        validate_targets(params[:targets])

        perform
      end

      private

      def exit_with_help
        puts help
        exit 0
      end

      def perform
        targets.each do |target_name|
          puts "Pretending to run something on #{target_name}..."
        end
      end

      def targets
        Array(params[:target])
      end

      def validate_inputs
        return if params.errors.empty?

        puts params.errors.summary
        exit 1
      end

      def validate_targets(target_names)
        target_names = Array(target_names)
        targets = Config.load["targets"] || {}
        known_targets = targets.keys.map(&:to_s)

        unknown_targets = target_names.reject do |target_name|
          known_targets.include?(target_name)
        end
        return if unknown_targets.empty?

        puts "Unknown targets: #{unknown_targets.join(', ')}. Expected one of: #{known_targets.join(', ')}"
        exit 1
      end
    end

    class TargetsTask < Task
      command "targets"

      usage do
        desc "List known targets"
      end

      def run
        targets = Styr.instance.targets.map do |target|
          [target.name, target.backend, target.config["app"]]
        end

        table = TTY::Table.new(
          :header => ["Name", "Backend", "App"],
          :rows => targets
        )

        puts table.render(:ascii)
      end
    end
  end
end

input_command = ARGV.first.to_s.downcase
app = Styr.instance
app.process_input_command(input_command, ARGV[1..])
